<?php
// $Id$

/**
 * @file
 * Administration pages for the module.
 */

/**
 * Filter settings form.
 *
 * @ingroup forms
 */
function wysiwyg_filter_settings_filter($format) {
  global $base_url;
  drupal_add_css(drupal_get_path('module', 'wysiwyg_filter') .'/wysiwyg_filter.admin.css', 'module', 'all', FALSE);

  $form = array();
  $form['wysiwyg_filter'] = array(
    '#type' => 'fieldset',
    '#title' => t('WYSIWYG Filter'),
    '#collapsible' => TRUE, '#collapsed' => FALSE,
  );

  $valid_elements = wysiwyg_filter_get_valid_elements($format);
  $form['wysiwyg_filter']['wysiwyg_filter_valid_elements_raw_'. $format] = array(
    '#type' => 'textarea',
    '#title' => t('HTML elements and attributes'),
    '#default_value' => $valid_elements,
    '#cols' => 60,
    '#rows' => min(20, max(5, substr_count($valid_elements, "\n") + 2)),
    '#description' => t('<p>
This option allows you to specify which HTML elements and attributes are allowed in <a href="@valid-elements">TinyMCE valid_elements format</a>.
</p>
<strong>Syntax tips:</strong><ul>
  <li>Use a comma separated list to allow several HTML elements. Example: &quot;em,strong,br,p,ul,ol,li&quot;. Note that you can split your definitions using any number of lines.</li>
  <li>Use square brackets &quot;[]&quot; to specify the attributes that are allowed for each HTML element. Attributes should be whitelisted explicitly, otherwise element attributes will be ignored. Example: &quot;a&quot; will NOT allow users to post links, you should use &quot;a[href]&quot; instead!</li>
  <li>Use the vertical bar character &quot;|&quot; to separate several attribute definitions for a single HTML element. Example: &quot;a[href|target]&quot; means users may optionally specify the &quot;href&quot; and &quot;target&quot; attributes for &quot;a&quot; elements, any other attribute will be ignored.</li>
  <li>Use the exclamation mark &quot;!&quot; to set one attribute as being required for a particular HTML element. Example: &quot;a[!href|target]&quot; means users must specify the &quot;href&quot; attribute, otherwise the whole &quot;a&quot; element will be ignored. Users may optionally specify the &quot;target&quot; attribute as well. However, any other attribute will be ignored.</li>
  <li>Use the asterisk symbol &quot;*&quot; to whitelist all possible attributes for a particular HTML element. Example: &quot;a[*]&quot; means users will be allowed to use any attribute for the &quot;a&quot; element.</li>
  <li>Use the at sign character &quot;@&quot; to whitelist a common set of attributes for all allowed HTML elements. Example: &quot;@[class|style]&quot; means users will be allowed to use the &quot;class&quot; and &quot;style&quot; attributes for any whitelisted HTML element.</li>
  <li>For further information and examples, please consult documentation of the <a href="@valid-elements">valid_elements</a> option in the TinyMCE Wiki site.</li>
</ul>
<strong>Additional notes:</strong><ul>
  <li>JavaScript event attributes such as onclick, onmouseover, etc. are always ignored. Should you need them, please consider using the &quot;Full HTML&quot; input format instead.</li>
  <li>If you allow usage of the attributes &quot;id&quot;, &quot;class&quot; and/or &quot;style&quot;, then you should also select which style properties are allowed and/or specify explicit matching rules for them using the &quot;Advanced rules&quot; section below.</li>
</ul>', array(
      '@valid-elements' => 'http://wiki.moxiecode.com/index.php/TinyMCE:Configuration/valid_elements',
    )),
  );

  $form['wysiwyg_filter']['styles'] = array(
    '#type' => 'fieldset',
    '#title' => t('Style properties'),
    '#collapsible' => TRUE, '#collapsed' => TRUE,
    '#description' =>
      '<p>'. t('This section allows you to select which style properties can be used for HTML elements where the &quot;style&quot; attribute has been allowed. The <em>WYSIWYG Filter</em> will strip out style properties (and their values) not explicitly enabled here. On the other hand, for allowed style properties the <em>WYSIWYG Filter</em> will check their values for strict CSS syntax and strip out those that do not match.') .'</p>'.
      '<p>'. t('Additional matching rules should be specified from the &quot;Advanced rules&quot; section below for a few of these properties that may contain URLs in their values (&quot;background&quot;, &quot;background-image&quot;, &quot;list-style&quot; and &quot;list-style-image&quot;). Otherwise, these style properties will be ignored from user input.') .'</p>',
  );
  $style_property_groups = wysiwyg_filter_get_style_property_groups();
  $i = 0;
  foreach ($style_property_groups as $group => $group_info) {
    $form['wysiwyg_filter']['styles']['wysiwyg_filter_styles_'. $group .'_'. $format] = array(
      '#type' => 'checkboxes',
      '#title' => $group_info['title'],
      '#default_value' => variable_get('wysiwyg_filter_styles_'. $group .'_'. $format, array()),
      '#options' => drupal_map_assoc(array_keys($group_info['properties'])),
      '#prefix' => '<div class="wysiwyg-filter-style-properties-group">', '#suffix' => '</div>',
    );
    if (($i % 3) == 2) {
      $form['wysiwyg_filter']['styles']['wysiwyg_filter_styles_'. $group .'_'. $format]['#suffix'] .= '<div class="clear-block"></div>';
    }
    $i++;
  }

  $form['wysiwyg_filter']['advanced_rules'] = array(
    '#type' => 'fieldset',
    '#title' => t('Advanced rules'),
    '#collapsible' => TRUE, '#collapsed' => TRUE,
    '#description' => '<p>'. t('Use the following options to configure additional rules for certain HTML element attributes. As a safety measure, these rules should be defined explicitly. Otherwise, the corresponding HTML element attributes will be ignored from user input.') .'</p>',
  );
  foreach (wysiwyg_filter_get_advanced_rules() as $rule_key => $rule_info) {
    $field_name = 'wysiwyg_filter_'. $rule_key .'_'. $format;
    $default_value = implode(",\n", variable_get($field_name, array()));
    $form['wysiwyg_filter']['advanced_rules'][$field_name] = array(
      '#type' => 'textarea',
      '#title' => $rule_info['title'],
      '#default_value' => $default_value,
      '#cols' => 60,
      '#rows' => min(10, max(2, substr_count($default_value, "\n") + 2)),
      '#description' => $rule_info['description'],
    );
  }

  $form['wysiwyg_filter']['nofollow'] = array(
    '#type' => 'fieldset',
    '#title' => t('Spam link deterrent settings'),
    '#collapsible' => TRUE, '#collapsed' => TRUE,
    '#description' => t('As a measure to reduce the effectiveness of spam links, it is often recommended to add rel=&quot;nofollow&quot; to posted links leading to external sites. The WYSIWYG Filter can easily do this for you while HTML is being processed with almost no additional performance impact.'),
  );
  $form['wysiwyg_filter']['nofollow']['wysiwyg_filter_nofollow_policy_'. $format] = array(
    '#type' => 'radios',
    '#title' => t('Policy'),
    '#options' => array(
      'disabled' => t('Disabled - Do not add rel=&quot;nofollow&quot; to any link.'),
      'whitelist' => t('Whitelist - Add rel=&quot;nofollow&quot; to all links except those leading to domain names specified in the list below.'),
      'blacklist' => t('Blacklist - Add rel=&quot;nofollow&quot; to all links leading to domain names specified in the list below.'),
    ),
    '#default_value' => variable_get('wysiwyg_filter_nofollow_policy_'. $format, 'disabled'),
    '#description' => t('If you choose the whitelist option, be sure to add your own domain names to the list!'),
  );
  $parts = parse_url($base_url);
  // Note that domains list is stored by our submit handler in array form where
  // dots have been escaped, so we need here to revert the process to get a clean
  // string for user input where dots are unescaped.
  $nofollow_domains = str_replace('\.', '.', implode(",\n", variable_get('wysiwyg_filter_nofollow_domains_'. $format, array($parts['host']))));
  $form['wysiwyg_filter']['nofollow']['wysiwyg_filter_nofollow_domains_'. $format] = array(
    '#type' => 'textarea',
    '#title' => t('Domains list'),
    '#default_value' => $nofollow_domains,
    '#cols' => 60,
    '#rows' => min(10, max(5, substr_count($nofollow_domains, "\n") + 2)),
    '#description' => t('Enter a comma separated list of top level domain names. Note that all subdomains will also be included. Example: example.com will match example.com, www.example.com, etc.'),
  );

  $form['#validate'] = array('wysiwyg_filter_settings_filter_validate');
  $form['#submit'] = array('wysiwyg_filter_settings_filter_submit');

  return $form;
}

/**
 * Validate filter settings form.
 *
 * @ingroup forms
 */
function wysiwyg_filter_settings_filter_validate($form, &$form_state) {
  $format = $form_state['values']['format'];

  foreach (wysiwyg_filter_get_advanced_rules() as $rule_key => $rule_info) {
    $field_name = 'wysiwyg_filter_'. $rule_key .'_'. $format;
    $expressions = array_filter(explode(',', preg_replace('#\s+#', ',', trim($form_state['values'][$field_name]))));
    $errors = array();
    foreach ($expressions as $expression) {
      if (preg_match('`[*?]\*|\*\?`', $expression)) {
        $errors[] = t('Invalid expression %expression. Please, do not use more than one consecutive asterisk (**) or one that is next to a question mark wildcard (?* or *?).', array('%expression' => $expression));
      }
      if (!preg_match($rule_info['validate_regexp'], $expression)) {
        $errors[] = t('Invalid expression %expression. Please, check the syntax of the %field field.', array('%expression' => $expression, '%field' => $rule_info['title']));
      }
    }
    if (!empty($errors)) {
      form_set_error($field_name, implode('<br />', $errors));
    }
  }

  $nofollow_domains = array_filter(explode(',', preg_replace('#\s+#', ',', $form_state['values']['wysiwyg_filter_nofollow_domains_'. $format])));
  foreach ($nofollow_domains as $nofollow_domain) {
    if (!preg_match('#^([a-z0-9]([-a-z0-9]*)?\.)+([a-z]+)$#i', $nofollow_domain)) {
      form_set_error('wysiwyg_filter_nofollow_domains_'. $format, t('Invalid domain %domain. Please, enter a comma separated list of valid domain names.', array('%domain' => $nofollow_domain)));
    }
  }
}

/**
 * Submit processing for the filter settings form.
 *
 * Parse filter options to help us save resources that would otherwiese
 * require time and precious cpu cycles at filter processing time.
 *
 * @ingroup forms
 */
function wysiwyg_filter_settings_filter_submit($form, &$form_state) {
  $format = $form_state['values']['format'];

  // Save trimmed version of user input.
  $valid_elements = trim($form_state['values']['wysiwyg_filter_valid_elements_raw_'. $format]);
  $form_state['values']['wysiwyg_filter_valid_elements_raw_'. $format] = $valid_elements;

  // Store an additional parsed version of valid_elements data.
  $valid_elements = wysiwyg_filter_parse_valid_elements($valid_elements);
  variable_set('wysiwyg_filter_valid_elements_parsed_'. $format, $valid_elements);

  // Transform user input (strings) into arrays.
  foreach (array_keys(wysiwyg_filter_get_advanced_rules()) as $rule_key) {
    $field_name = 'wysiwyg_filter_'. $rule_key .'_'. $format;
    $expressions = array_filter(explode(',', preg_replace('#\s+#', ',', trim($form_state['values'][$field_name]))));
    $form_state['values'][$field_name] = $expressions;
  }

  // Transform user input (strings) into an array.
  // Dots are escaped to speed up a little the job of the filter process.
  $nofollow_domains = array_filter(explode(',', preg_replace('#\s+#', ',', str_replace('.', '\.', $form_state['values']['wysiwyg_filter_nofollow_domains_'. $format]))));
  $form_state['values']['wysiwyg_filter_nofollow_domains_'. $format] = $nofollow_domains;
}

/**
 * Parse valid_elements string in TinyMCE format.
 *
 * @see http://wiki.moxiecode.com/index.php/TinyMCE:Configuration/valid_elements
 *
 * @param string $valid_elements
 *
 * @return array
 *   Information about allowed HTML elements and attributes.
 *   Each HTML element contains a whitelist of attributes or '*' meaning all
 *   attributes are allowed for that element.
 *   Each attribute contains an array with one or more of the following items
 *   of information:
 *   - required   boolean   TRUE when attribute is required.
 *   - default    string    Default value that will be applied when only the
 *                          attribute name is specified.
 *   - forced     string    Value that will be applied when the attribute is
 *                          present in the parsed HTML stream.
 *   - values     array     Whitelist of attribute values.
 *   This information is used by the WYSIWYG Filter itself to filter out
 *   disallowed HTML elements and attributes.
 *
 * @see wysiwyg_filter_process()
 */
function wysiwyg_filter_parse_valid_elements($valid_elements) {
  // Remove whitespaces and split valid elements from a comma separate list of items.
  $valid_elements = array_map('drupal_strtolower', array_filter(explode(',', preg_replace('#\s+#', '', $valid_elements))));
  $parsed_elements = array();
  $common_attributes = array();
  foreach ($valid_elements as $valid_element) {
    // Extract the element name and its allowed attributes list
    // including special characters that will be parsed later.
    if (preg_match('`^(@|[#+-]{0,1}[a-z0-9/]+)(\[([^]]*)\])*$`', $valid_element, $matches)) {
      // Element names can be specified by the special character "@" (used
      // to allow a common set of attributes for all valid HTML elements)
      // or a list of names separated by the special character "/".
      $elements = array_unique(array_filter(explode('/', $matches[1])));

      // Parse allowed attributes list (empty list means no attributes are allowed).
      $attributes = array();
      if (!empty($matches[3])) {
        // More than one attribute can be specified in the list (separator: "|").
        foreach (array_filter(explode('|', $matches[3])) as $attribute) {
          // Split item into attribute name and (optional) attribute options.
          $attribute_options = array();
          if (preg_match('`^([-a-z]+)([=:<].*)$`', $attribute, $match)) {
            $attribute = $match[1];

            // Parse attribute options.
            if (strpos('=:<', $match[2][0]) !== FALSE) {
              $operator = $match[2][0];
              if ($operator == '=') {
                // Default value for the attribute (applied when present without explicit value).
                $attribute_options['default'] = substr($match[2], 1);
              }
              else if ($operator == ':') {
                // Forced value for the attribute (applied when present regardless of the specified value).
                $attribute_options['forced'] = substr($match[2], 1);
              }
              else if ($operator == '<') {
                // This attribute accepts only the specified list of values (separator: "?").
                $attribute_options['values'] = array_unique(array_filter(explode('?', substr($match[2], 1))));
              }
            }
          }

          // Are all attributes allowed for this element?
          if ($attribute == '*') {
            $attributes['*'] = array();
            continue;
          }

          if (substr($attribute, 0, 1) == '!') {
            // If this attribute is not present in parsed HTML, then
            // the whole HTML element will be stripped out.
            $attribute = substr($attribute, 1);
            $attribute_options['required'] = TRUE;
          }

          // Ignore malformed attribute names.
          if (!preg_match('`^[a-z][-a-z]*$`', $attribute)) {
            continue;
          }

          // Attributes related to DOM events (on*) are not allowed here.
          if (substr($attribute, 0, 2) == 'on') {
            continue;
          }

          // Collect attribute options.
          if (!isset($attributes[$attribute])) {
            $attributes[$attribute] = array();
          }
          foreach ($attribute_options as $option_type => $option_value) {
            $attributes[$attribute][$option_type] = $option_value;
          }
        }
      }

      // Obtain list of element names/synonyms (separated by /).
      // Consider synonyms as different elements with same exact attributes.
      foreach ($elements as $element) {
        if ($element == '@') {
          // These attributes should be enabled for all elements.
          foreach ($attributes as $attribute => $attribute_options) {
            if (!isset($common_attributes[$attribute])) {
              $common_attributes[$attribute] = array();
            }
            foreach ($attribute_options as $option_type => $option_value) {
              $common_attributes[$attribute][$option_type] = $option_value;
            }
          }
        }
        else {
          // Ignore element name prefixes (+ - #) that are allowed for the
          // TynyMCE valid_elements parameter, but for the sake of simplicity,
          // our server side filter ignores them.
          if (strpos('+-#', $element[0]) !== FALSE) {
            $element = substr($element, 1);
          }
          if (!isset($parsed_elements[$element])) {
            $parsed_elements[$element] = array();
          }
          if (!isset($parsed_elements[$element]['*'])) {
            foreach ($attributes as $attribute => $attribute_options) {
              if ($attribute == '*') {
                $parsed_elements[$element] = array('*' => array());
                break;
              }
              if (!isset($parsed_elements[$element][$attribute])) {
                $parsed_elements[$element][$attribute] = array();
              }
              foreach ($attribute_options as $option_type => $option_value) {
                $parsed_elements[$element][$attribute][$option_type] = $option_value;
              }
            }
          }
        }
      }
    }
  }

  if (!empty($common_attributes)) {
    // Append commonly allowed attributes to each allowed element.
    foreach ($parsed_elements as $element => &$attributes) {
      // Do not append common attributes when all are allowed.
      if (isset($parsed_elements[$element]['*'])) {
        continue;
      }
      foreach ($common_attributes as $attribute => $attribute_options) {
        if (!isset($attributes[$attribute])) {
          $attributes[$attribute] = array();
        }
        foreach ($attribute_options as $option_type => $option_value) {
          $attributes[$attribute][$option_type] = $option_value;
        }
      }
    }
  }

  return $parsed_elements;
}
