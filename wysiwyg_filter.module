<?php
// $Id$

/**
 * @file
 * Provides an input filter that allows site administrators configure which
 * HTML elements, attributes and style properties are allowed.
 */

/**
 * Implementation of hook_filter().
 */
function wysiwyg_filter_filter($op, $delta = 0, $format = -1, $text = '') {
  if ($op == 'list') {
    return array(0 => t('WYSIWYG Filter'));
  }
  else if ($op == 'description') {
    if ($delta == 0) {
      return t('Allows you to restrict whether users can post HTML and which tags and attributes per HTML tag to filter out.');
    }
  }
  else if ($op == 'no cache') {
    return TRUE; // FIXME - No caching while on development !!!
  }
  else if ($op == 'settings') {
    if ($delta == 0) {
      module_load_include('inc', 'wysiwyg_filter', 'wysiwyg_filter.admin');
      return wysiwyg_filter_settings_filter($format);
    }
  }
  else if ($op == 'process') {
    if ($delta == 0) {
      return wysiwyg_filter_process($text, $format);
    }
  }
  else {
    return $text;
  }
}

/**
 * Implementation of hook_filter_tips().
 */
function wysiwyg_filter_filter_tips($delta, $format, $long = FALSE) {
  if ($delta == 0) {
    $filter_options = wysiwyg_filter_get_filter_options($format);
    $output = '';
    if (!empty($filter_options['valid_elements'])) {
      $output .= '<p>'. t('Allowed HTML tags: @tags', array('@tags' => implode(', ', array_keys($filter_options['valid_elements'])))) .'.</p>';
    }
    if (!empty($filter_options['style_properties'])) {
      $output .= '<p>'. t('Allowed Style properties: @properties', array('@properties' => implode(', ', array_keys($filter_options['style_properties'])))) .'.</p>';
    }
    return $output;
  }
}

/**
 * Helper function to get information about fields that implement
 * advanced rules.
 *
 * @see wysiwyg_filter_get_filter_options()
 * @see wysiwyg_filter_settings_filter()
 * @see wysiwyg_filter_settings_filter_validate()
 * @see wysiwyg_filter_settings_filter_submit()
 */
function wysiwyg_filter_get_advanced_rules() {
  global $base_url, $base_path;
  return array(
    'valid_classes' => array(
      'title' => t('Rules for Class Names'),
      'description' => t('Enter a comma separated list of rules for <em>Class Names</em>. Whitespaces and line-breaks are ignored. <em>Class Names</em> should start with a lower case letter &quot;a-z&quot; and can be followed by one or more lower case letters &quot;a-z&quot;, digits &quot;0-9&quot;, hyphens &quot;-&quot; and/or underscores &quot;_&quot;. The asterisk character &quot;*&quot; can be used in rules to represent any number of characters from the second position of the rule. Example: &quot;userclass*, my-font-*&quot; are valid rules for <em>Class Names</em>, whereas &quot;*class&quot; is invalid.'),
      'validate_regexp' => '`^[a-z][-_a-z0-9?*]*$`',
      'asterisk_expansion' => '[-_a-z0-9]*',
    ),
    'valid_ids' => array(
      'title' => t('Rules for Element IDs'),
      'description' => t('Enter a comma separated list of rules for <em>Element IDs</em>. Whitespaces and line-breaks are ignored. <em>Element IDs</em> should start with a lower case letter &quot;a-z&quot; and can be followed by one or more lower case letters &quot;a-z&quot;, digits &quot;0-9&quot;, hyphens &quot;-&quot; and/or underscores &quot;_&quot;. The asterisk character &quot;*&quot; can be used in rules to represent any number of characters from the second position of the rule. Example: &quot;foo*&quot; is a valid rule for <em>Element IDs</em>, whereas &quot;*bar&quot; is invalid.'),
      'validate_regexp' => '`^[a-z][-_a-z0-9?*]*$`',
      'asterisk_expansion' => '[-_a-z0-9]*',
    ),
    'style_urls' => array(
      'title' => t('Rules for URLs used within inline styles'),
      'description' => t('Enter a comma separated list of rules for <em>URLs used within inline styles</em>. Whitespaces and line-breaks are ignored. These rules affect the following style properties: &quot;background&quot;, &quot;background-image&quot;, &quot;list-style&quot; and &quot;list-style-image&quot;. Each rule represents a single path or URL. The asterisk character &quot;*&quot; can be used to represent any number of characters. Examples: use &quot;/*&quot; for local URLs only, use &quot;/images/*&quot; for one particular directory, use &quot;http://www.example.com/*&quot; for URLs of an external site, use &quot;@base-path*, @base-url*&quot; for URLs of your own site.', array('@base-path' => $base_path, '@base-url' => $base_url)),
      'validate_regexp' => '`^.*$`',
      'asterisk_expansion' => '.*',
    ),
  );
}

/**
 * Get filter options.
 *
 * @param int $format
 *   Input format identifier.
 * @return array
 *   An array with the following items:
 *   - valid_elements   : Whitelist of HTML elements and attributes.
 *   - style_properties : Whitelist of style properties.
 */
function wysiwyg_filter_get_filter_options($format) {
  $filter_options = array(
    'valid_elements' => wysiwyg_filter_get_valid_elements($format, TRUE),
    'style_properties' => wysiwyg_filter_get_style_properties($format),
    'nofollow_policy' => variable_get('wysiwyg_filter_nofollow_policy_'. $format, 'disabled'),
    'nofollow_domains' => variable_get('wysiwyg_filter_nofollow_domains_'. $format, array()),
  );
  foreach (wysiwyg_filter_get_advanced_rules() as $rule_key => $rule_info) {
    $filter_options[$rule_key] = array();
    foreach (variable_get('wysiwyg_filter_'. $rule_key .'_'. $format, array()) as $rule) {
      $filter_options[$rule_key][] = '`^'. str_replace("\xFF", $rule_info['asterisk_expansion'], preg_quote(str_replace('*', "\xFF", $rule), '`')) .'$`';
    }
  }
  return $filter_options;
}

/**
 * Get allowed style properties.
 *
 * @param int $format
 *   Input format identifier.
 * @return array
 */
function wysiwyg_filter_get_style_properties($format) {
  static $style_properties = array();
  if (!isset($style_properties[$format])) {
    $style_properties[$format] = array();
    foreach (wysiwyg_filter_get_style_property_groups() as $group => $group_info) {
      $allowed_styles = array_filter(variable_get('wysiwyg_filter_styles_'. $group .'_'. $format, array()));
      foreach ($group_info['properties'] as $property => $regexp) {
        if (isset($allowed_styles[$property])) {
          $style_properties[$format][$property] = '`^'. $regexp .'$`';
        }
      }
    }
  }
  return $style_properties[$format];
}

/**
 * Obtain list of style properties along their syntax rules.
 *
 * Style property information in compiled in logical groups, so it's
 * easier to build the filter settings form.
 *
 * Note that regular expression quantifiers are limited by number
 * of digits/characters. This is to prevent users from posting
 * big numbers/strings in property values that could cause browsers
 * to crash due to overflows, or any other kind of issue. Note that
 * users will still be able to break page layouts when using certain
 * combinations of numbers and units (ie. 100em, etc.), but nothing
 * more than that, hopefully.
 * This kind of issues may also happen when validating HTML attributes
 * where values are just checked for bad protocols. This is the same
 * exact measure taken by Drupal's filter_xss(), which has been a
 * friend of us for a long time. IMHO, it's a matter of balance
 * between performance, code complexity, etc. and... perfection?
 *
 * All regular expressions are aimed to be delimited by `^ and $`.
 *
 * @return array
 *
 * @see wysiwyg_filter_get_style_properties()
 * @see wysiwyg_filter_settings_filter()
 */
function wysiwyg_filter_get_style_property_groups() {
  $regexp_integer = '[-]?[0-9]{1,3}';
  $regexp_number = '[-]?(?:[0-9]{0,3}|[0-9]{0,3}\.[0-9]{1,4})';
  $regexp_length = $regexp_number .'(?:px|pt|em|ex|in|cm|mm|pc)?';
  $regexp_percent = '[-]?[12][0-9]{1,2}%';
  $regexp_color = '#[a-fA-F0-9]{3}|#[a-fA-F0-9]{6}|rgb\(?:\s*[0-9]{0,3}%?(?:\s*,\s*[0-9]{0,3}%?){2}\s*\)|[a-zA-Z]+';
  $regexp_border_width = $regexp_length .'|thin|medium|thick';
  $regexp_border_style = 'none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset';
  $regexp_uri = 'url\(\s*[\'"]?(?:[^)]|(?<=\\\\)\\))+[\'"]?\s*\)';
  $regexp_shape = 'rect\(\s*(?:auto|'. $regexp_length .')(?:\s+(?:auto|'. $regexp_length .')){3}\s*\)';
  $regexp_list_style_type = 'none|disc|circle|square|decimal(?:-leading-zero)?|lower-(?:alpha|greek|latin|roman)|upper-(?:alpha|latin|roman)|hebrew|armenian|georgian|cjk-ideographic|hiragana(?:-iroha)?|katakana(?:-iroha)?';

  // Note that shorthand properties such as background and font are built
  // below, so we can reuse regular expression definitions.
  $groups = array(
    'color' => array(
      'title' => t('Color and background properties'),
      'properties' => array(
        'color' => '(?:'. $regexp_color .')',
        'background' => '', // See this property expanded below.
        'background-color' => '(?:'. $regexp_color .'|transparent)',
        'background-image' => '(?:none|'. $regexp_uri .')',
        'background-repeat' => '(?:no-repeat|repeat(?:-x|-y)?)',
        'background-attachment' => '(?:scroll|fixed)',
        'background-position' => '(?:(?:(?:top|center|bottom|left|right)(?:\s+(?:top|center|bottom|left|right))?)|(?:(?:'. $regexp_length .'|'. $regexp_percent .')(?:\s+(?:'. $regexp_length .'|'. $regexp_percent .'))?))',
      ),
    ),
    'font' => array(
      'title' => t('Font properties'),
      'properties' => array(
        'font' => '', // See this property expanded below.
        'font-family' => '(?:[-_a-zA-Z0-9"\' ]*(?:\s*,\s*[-_a-zA-Z0-9"\' ]*)*)',
        'font-size' => '(?:(?:x-|xx-)?(?:small|large)(?:er)?|medium|'. $regexp_length .'|'. $regexp_percent .')',
        'font-size-adjust' => '(?:none|'. $regexp_number .')',
        'font-stretch' => '(?:normal|wider|narrower|(?:ultra-|extra-|semi-)?(?:condensed|expanded))',
        'font-style' => '(?:normal|italic|oblique)',
        'font-variant' => '(?:normal|small-caps)',
        'font-weight' => '(?:normal|bold|bolder|lighter|[1-9]00)',
      ),
    ),
    'text' => array(
      'title' => t('Text properties'),
      'properties' => array(
        'text-align' => '(?:left|right|center|justify)',
        'text-decoration' => '(?:none|underline|overline|line-through|blink)',
        'text-indent' => '(?:'. $regexp_length .'|'. $regexp_percent .')',
        'text-transform' => '(?:none|capitalize|(?:upper|lower)case)',
        'letter-spacing' => '(?:normal|'. $regexp_length .')',
        'word-spacing' => '(?:normal|'. $regexp_length .')',
        'white-space' => '(?:normal|pre|nowrap)',
        'direction' => '(?:ltr|rtl)',
        'unicode-bidi' => '(?:normal|embed|bidi-override)',
      ),
    ),
    'box' => array(
      'title' => t('Box properties'),
      'properties' => array(
        'margin' => '(?:auto|'. $regexp_length .'|'. $regexp_percent .'(?:\s+(?:auto|'. $regexp_length .'|'. $regexp_percent .')){0,3})',
        'margin-top' => '(?:auto|'. $regexp_length .'|'. $regexp_percent .')',
        'margin-right' => '(?:auto|'. $regexp_length .'|'. $regexp_percent .')',
        'margin-bottom' => '(?:auto|'. $regexp_length .'|'. $regexp_percent .')',
        'margin-left' => '(?:auto|'. $regexp_length .'|'. $regexp_percent .')',
        'padding' => '(?:'. $regexp_length .'|'. $regexp_percent .'(?:\s+(?:'. $regexp_length .'|'. $regexp_percent .')){0,3})',
        'padding-top' => '(?:'. $regexp_length .'|'. $regexp_percent .')',
        'padding-right' => '(?:'. $regexp_length .'|'. $regexp_percent .')',
        'padding-bottom' => '(?:'. $regexp_length .'|'. $regexp_percent .')',
        'padding-left' => '(?:'. $regexp_length .'|'. $regexp_percent .')',
      ),
    ),
    'border-1' => array(
      'title' => t('Border properties (1)'),
      'properties' => array(
        'border' => '(?:(?:'. $regexp_border_width .')?(?:\s*(?:'. $regexp_border_style .')?(?:\s*(?:'. $regexp_color .'|transparent)?)))',
        'border-top' => '(?:(?:'. $regexp_border_width .')?(?:\s*(?:'. $regexp_border_style .')?(?:\s*(?:'. $regexp_color .'|transparent)?)))',
        'border-right' => '(?:(?:'. $regexp_border_width .')?(?:\s*(?:'. $regexp_border_style .')?(?:\s*(?:'. $regexp_color .'|transparent)?)))',
        'border-bottom' => '(?:(?:'. $regexp_border_width .')?(?:\s*(?:'. $regexp_border_style .')?(?:\s*(?:'. $regexp_color .'|transparent)?)))',
        'border-left' => '(?:(?:'. $regexp_border_width .')?(?:\s*(?:'. $regexp_border_style .')?(?:\s*(?:'. $regexp_color .'|transparent)?)))',
        'border-width' => '(?:'. $regexp_border_width .'(?:\s+(?:'. $regexp_border_width .')){0,3})',
        'border-top-width' => '(?:'. $regexp_border_width .')',
        'border-right-width' => '(?:'. $regexp_border_width .')',
        'border-bottom-width' => '(?:'. $regexp_border_width .')',
        'border-left-width' => '(?:'. $regexp_border_width .')',
      ),
    ),
    'border-2' => array(
      'title' => t('Border properties (2)'),
      'properties' => array(
        'border-color' => '(?:'. $regexp_color .'|transparent(?:\s+(?:'. $regexp_color .'|transparent)){0,3})',
        'border-top-color' => '(?:'. $regexp_color .'|transparent)',
        'border-right-color' => '(?:'. $regexp_color .'|transparent)',
        'border-bottom-color' => '(?:'. $regexp_color .'|transparent)',
        'border-left-color' => '(?:'. $regexp_color .'|transparent)',
        'border-style' => '(?:'. $regexp_border_style .'(?:\s+(?:'. $regexp_border_style .')){0,3})',
        'border-top-style' => '(?:'. $regexp_border_style .')',
        'border-right-style' => '(?:'. $regexp_border_style .')',
        'border-bottom-style' => '(?:'. $regexp_border_style .')',
        'border-left-style' => '(?:'. $regexp_border_style .')',
      ),
    ),
    'dimension' => array(
      'title' => t('Dimension properties'),
      'properties' => array(
        'height' => '(?:auto|'. $regexp_length .'|'. $regexp_percent .')',
        'line-height' => '(?:normal|'. $regexp_number .'|'. $regexp_length .'|'. $regexp_percent .')',
        'max-height' => '(?:none|'. $regexp_length .'|'. $regexp_percent .')',
        'max-width' => '(?:none|'. $regexp_length .'|'. $regexp_percent .')',
        'min-height' => '(?:'. $regexp_length .'|'. $regexp_percent .')',
        'min-width' => '(?:'. $regexp_length .'|'. $regexp_percent .')',
        'width' => '(?:auto|'. $regexp_length .'|'. $regexp_percent .')',
      ),
    ),
    'positioning' => array(
      'title' => t('Positioning properties'),
      'properties' => array(
        'bottom' => '(?:auto|'. $regexp_length .'|'. $regexp_percent .')',
        'clip' => '(?:auto|'. $regexp_shape .')',
        'left' => '(?:auto|'. $regexp_length .'|'. $regexp_percent .')',
        'overflow' => '(?:visible|hidden|scroll|auto)',
        'right' => '(?:auto|'. $regexp_length .'|'. $regexp_percent .')',
        'top' => '(?:auto|'. $regexp_length .'|'. $regexp_percent .')',
        'vertical-align' => '(?:baseline|sub|super|middle|(?:text-)?(?:top|bottom)|'. $regexp_length .'|'. $regexp_percent .')',
        'z-index' => '(?:auto|'. $regexp_integer .')',
      ),
    ),
    'layout' => array(
      'title' => t('Layout properties'),
      'properties' => array(
        'clear' => '(?:left|right|both|none)',
        'display' => '(?:none|inline|block|list-item|run-in|compact|marker|table-(?:(?:row|header|group|column)-group|row|column|cell|caption)|(?:inline-)?table)',
        'float' => '(?:left|right|none)',
        'position' => '(?:static|relative|absolute|fixed)',
        'visibility' => '(?:visible|hidden|collapse)',
      ),
    ),
    'list' => array(
      'title' => t('List properties'),
      'properties' => array(
        'list-style' => '(?:(?:'. $regexp_list_style_type .')?(?:\s*(?:(?:in|out)side)?(?:\s*(?:none|'. $regexp_uri .')?)))',
        'list-style-image' => '(?:none|'. $regexp_uri .')',
        'list-style-position' => '(?:inside|outside)',
        'list-style-type' => '(?:'. $regexp_list_style_type .')',
      ),
    ),
    'table' => array(
      'title' => t('Table properties'),
      'properties' => array(
        'border-collapse' => '(?:collapse|separate)',
        'border-spacing' => '(?:'. $regexp_length .'(?:\s+'. $regexp_length .')?)',
        'caption-side' => '(?:top|bottom|left|right)',
        'empty-cells' => '(?:show|hide)',
        'table-layout' => '(?:auto|fixed)',
      ),
    ),
    'user' => array(
      'title' => t('User interface properties'),
      'properties' => array(
        'cursor' => '(?:auto|crosshair|default|pointer|move|(?:e|ne|nw|n|se|sw|s|w)-resize|text|wait|help)',
        'outline' => '(?:(?:'. $regexp_color .'|invert)?(?:\s*(?:'. $regexp_border_style .')?(?:\s*(?:'. $regexp_border_width .')?)))',
        'outline-width' => '(?:'. $regexp_border_width .')',
        'outline-style' => '(?:'. $regexp_border_style .')',
        'outline-color' => '(?:'. $regexp_color .'|invert)',
        'zoom' => '(?:normal|'. $regexp_number .'|'. $regexp_percent .')',
      ),
    ),
  );

  // 'background' property.
  $groups['color']['properties']['background'] = '(?:'.
    $groups['color']['properties']['background-color'] .'?(?:\s*'.
    $groups['color']['properties']['background-image'] .'?(?:\s*'.
    $groups['color']['properties']['background-repeat'] .'?(?:\s*'.
    $groups['color']['properties']['background-attachment'] .'?(?:\s*'.
    $groups['color']['properties']['background-position'] .'?)))))';

  // 'font' property.
  $groups['font']['properties']['font'] = '(?:(?:'.
    $groups['font']['properties']['font-style'] .'?(?:\s*'.
    $groups['font']['properties']['font-variant'] .'?(?:\s*'.
    $groups['font']['properties']['font-weight'] .'?)))\s*'.
    '(?:(?:'. $groups['font']['properties']['font-size'] .')(?:\s*/\s*'. $groups['dimension']['properties']['line-height'] .')?)?'.
    '(?:\s*'. $groups['font']['properties']['font-family'] .'?)?)';

  return $groups;
}

/**
 * Get allowed valid_elements for the given format ID.
 *
 * @param int $format
 *   Input format identifier.
 * @param boolean $parsed
 *   TRUE to return a preparsed array, FALSE to return a string.
 * @return mixed
 *   When $parsed is FALSE: returns a string as entered by the user in
 *                          in the filter settings form.
 *   When $parsed is TRUE : returns a preparsed array of valid_elements
 *                          information.
 *
 * @see wysiwyg_filter_settings_filter_submit()
 * @see wysiwyg_filter_parse_valid_elements()
 */
function wysiwyg_filter_get_valid_elements($format, $parsed = FALSE) {
  if ($parsed) {
    return variable_get('wysiwyg_filter_valid_elements_parsed_'. $format, array());
  }
  return variable_get('wysiwyg_filter_valid_elements_raw_'. $format, wysiwyg_filter_default_valid_elements());
}

/**
 * Obtain a string with default valid_elements.
 */
function wysiwyg_filter_default_valid_elements() {
  return <<<EOT
a[!href|target<_blank|title],
div[align<center?justify?left?right],
p[align<center?justify?left?right],
br,em,strong,cite,code,blockquote,ul,ol,li,dl,dt,dd
EOT;
}

/**
 * WYSIWYG Filter. Provides filtering of input into accepted HTML.
 *
 * This function is based on Drupal's filter_xss() with a few additions:
 * - Validates HTML input against whitelists of HTML elements, attributes
 *   and style properties.
 * - Optionally apply rel="nofollow" rules to links.
 * - Rules for the above can be specified by site administrators from the
 *   filter settings form.
 *
 * @param string $text
 *   HTML text to be filtered.
 * @param int $format
 *   Input format identifier.
 * @return string
 *   Filtered HTML text.
 */
function wysiwyg_filter_process($text, $format) {
  // Only operate on valid UTF-8 strings. This is necessary to prevent cross
  // site scripting issues on Internet Explorer 6.
  if (!drupal_validate_utf8($text)) {
    return '';
  }

  // Store input filter options.
  _wysiwyg_filter_xss_split(wysiwyg_filter_get_filter_options($format), TRUE);

  // Remove NUL characters (ignored by some browsers).
  $text = str_replace(chr(0), '', $text);
  // Remove Netscape 4 JS entities.
  $text = preg_replace('%&\s*\{[^}]*(\}\s*;?|$)%', '', $text);

  // Defuse all HTML entities.
  $text = str_replace('&', '&amp;', $text);
  // Change back only well-formed entities in our whitelist
  // Named entities.
  $text = preg_replace('/&amp;([A-Za-z][A-Za-z0-9]*;)/', '&\1', $text);
  // Decimal numeric entities.
  $text = preg_replace('/&amp;#([0-9]+;)/', '&#\1', $text);
  // Hexadecimal numeric entities.
  $text = preg_replace('/&amp;#[Xx]0*((?:[0-9A-Fa-f]{2})+;)/', '&#x\1', $text);

  return preg_replace_callback('%
    (
    <(?=[^a-zA-Z!/])  # a lone <
    |                 # or
    <[^>]*(>|$)       # a string that starts with a <, up until the > or the end of the string
    |                 # or
    >                 # just a >
    )%x', '_wysiwyg_filter_xss_split', $text);
}

/**
 * Processes an HTML tag.
 *
 * @param $m
 *   An array with various meaning depending on the value of $store.
 *   If $store is TRUE then the array contains the allowed tags.
 *   If $store is FALSE then the array has one element, the HTML tag to process.
 * @param $store
 *   Whether to store $m.
 * @return
 *   If the element isn't allowed, an empty string. Otherwise, the cleaned up
 *   version of the HTML element.
 */
function _wysiwyg_filter_xss_split($m, $store = FALSE) {
  static $filter_options;

  if ($store) {
    _wysiwyg_filter_xss_attributes($filter_options = $m);
    return;
  }

  $string = $m[1];

  if (substr($string, 0, 1) != '<') {
    // We matched a lone ">" character
    return '&gt;';
  }
  else if (strlen($string) == 1) {
    // We matched a lone "<" character
    return '&lt;';
  }

  if (!preg_match('%^<\s*(/\s*)?([a-zA-Z0-9]+)([^>]*)>?$%', $string, $matches)) {
    // Seriously malformed
    return '';
  }

  $slash = trim($matches[1]);
  $elem = strtolower($matches[2]);
  $attrlist = &$matches[3];

  if (!isset($filter_options['valid_elements'][$elem])) {
    // Disallowed HTML element.
    return '';
  }

  if ($slash != '') {
    return "</$elem>";
  }

  // Is there a closing XHTML slash at the end of the attributes?
  // In PHP 5.1.0+ we could count the changes, currently we need a separate match
  $xhtml_slash = preg_match('%\s?/\s*$%', $attrlist) ? ' /' : '';
  $attrlist = preg_replace('%(\s?)/\s*$%', '\1', $attrlist);

  // Clean up attributes
  if (($attr2 = _wysiwyg_filter_xss_attributes($attrlist, $elem)) === FALSE) {
    // Disallowed HTML element because it does not contain required attribute.
    return '';
  }
  $attr2 = implode(' ', $attr2);
  $attr2 = preg_replace('/[<>]/', '', $attr2);
  $attr2 = strlen($attr2) ? ' '. $attr2 : '';

  return "<$elem$attr2$xhtml_slash>";
}

/**
 * Processes a string of HTML attributes.
 *
 * @param mixed $attr
 *   String with attributes list to be checked.
 *   Array with whitelist of all HTML elements and their allowed attributes.
 * @param string $element
 *   Current element for specified attributes lists.
 * @return
 *   Cleaned up version of the HTML attributes.
 */
function _wysiwyg_filter_xss_attributes($attr, $element = '') {
  static $filter_options;

  if (is_array($attr)) {
    $filter_options = $attr;
// FIXME
//vd($filter_options);
    return;
  }

  // Shortcuts for filter options.
  $allowed_attributes = &$filter_options['valid_elements'][$element];
  $allowed_properties = &$filter_options['style_properties'];
  $allowed_style_urls = &$filter_options['style_urls'];
  $allowed_class_names = &$filter_options['valid_classes'];
  $allowed_element_ids = &$filter_options['valid_ids'];
  $nofollow_policy = &$filter_options['nofollow_policy'];
  $nofollow_domains = &$filter_options['nofollow_domains'];

  $attrarr = array();
  $mode = 0;
  $attrname = '';

  while (strlen($attr) != 0) {
    // Was the last operation successful?
    $working = 0;

    switch ($mode) {
      case 0:
        // Attribute name, href for instance.
        if (preg_match('/^([-a-zA-Z]+)/', $attr, $match)) {
          $attrname = strtolower($match[1]);
          $skip = (substr($attrname, 0, 2) == 'on' || (!isset($allowed_attributes[$attrname]) && !isset($allowed_attributes['*'])));
          $working = $mode = 1;
          $attr = preg_replace('/^[-a-zA-Z]+/', '', $attr);
        }

        break;

      case 1:
        // Equals sign or valueless ("selected").
        if (preg_match('/^\s*=\s*/', $attr)) {
          $working = 1; $mode = 2;
          $attr = preg_replace('/^\s*=\s*/', '', $attr);
          break;
        }

        if (preg_match('/^\s+/', $attr)) {
          $working = 1; $mode = 0;
          if (!$skip) {
            $attrarr[$attrname] = array();
          }
          $attr = preg_replace('/^\s+/', '', $attr);
        }

        break;

      case 2:
        // Attribute value, a URL after href= for instance.
        if (preg_match('/^"([^"]*)"(\s+|$)/', $attr, $match)) {
          if (!$skip) {
            $attrarr[$attrname] = array('value' => $match[1], 'delimiter' => '"');
          }
          $working = 1;
          $mode = 0;
          $attr = preg_replace('/^"[^"]*"(\s+|$)/', '', $attr);
          break;
        }

        if (preg_match("/^'([^']*)'(\s+|$)/", $attr, $match)) {
          if (!$skip) {
            $attrarr[$attrname] = array('value' => $match[1], 'delimiter' => '\'');
          }
          $working = 1; $mode = 0;
          $attr = preg_replace("/^'[^']*'(\s+|$)/", '', $attr);
          break;
        }

        if (preg_match("%^([^\s\"']+)(\s+|$)%", $attr, $match)) {
          if (!$skip) {
            $attrarr[$attrname] = array('value' => $match[1], 'delimiter' => '"');
          }
          $working = 1; $mode = 0;
          $attr = preg_replace("%^[^\s\"']+(\s+|$)%", '', $attr);
        }

        break;
    }

    if ($working == 0) {
      // not well formed, remove and try again.
      $attr = preg_replace('/
        ^
        (
        "[^"]*("|$)     # - a string that starts with a double quote, up until the next double quote or the end of the string
        |               # or
        \'[^\']*(\'|$)| # - a string that starts with a quote, up until the next quote or the end of the string
        |               # or
        \S              # - a non-whitespace character
        )*              # any number of the above three
        \s*             # any number of whitespaces
        /x', '', $attr);
      $mode = 0;
    }
  }

  // The attribute list ends with a valueless attribute like "selected".
  // Though, it can only be accepted if matches our filtering rules.
  if ($mode == 1 && substr($attrname, 0, 2) != 'on' && (isset($allowed_attributes[$attrname]) || isset($allowed_attributes['*']))) {
    $attrarr[$attrname] = array();
  }

  // Check the current HTML element for required attributes.
  foreach ($allowed_attributes as $attrname => $attrinfo) {
    if (!empty($attrinfo['required']) && !isset($attrarr[$attrname])) {
      // Ignore the whole element if required attribute is not present.
      return FALSE;
    }
  }

  // Check the current HTML element for additional attribute rules.
  $parsed_attributes = array();
  $add_nofollow = FALSE;
  foreach ($attrarr as $attrname => $attrinfo) {
    $parsed_attribute = $attrname;
    $attribute_options = (isset($allowed_attributes[$attrname]) ? $allowed_attributes[$attrname] : array());

    // When no attribute value has been specified in parsed HTML stream,
    // then supply default value if provided by input format settings.
    if (!isset($attrinfo['value']) && isset($attribute_options['default'])) {
      $attrinfo['value'] = $attribute_options['default'];
    }

    if (isset($attrinfo['value'])) {
      // Supply forced attribute value as defined by input format?
      if (isset($attribute_options['forced'])) {
        $attrinfo['value'] = $attribute_options['forced'];
      }
      else if (isset($attribute_options['values']) && !in_array($attrinfo['value'], $attribute_options['values'])) {
        // Ignore attribute if value is not present in whitelist.
        continue;
      }

      // Additional validation of attribute values.
      if ($attrname == 'style') {
        // Ok, let us validate individual style properties (decode entities now).
        $dirty_properties = array_filter(array_map('trim', explode(';', decode_entities($attrinfo['value']))));
        $sanitized_properties = array();
        foreach ($dirty_properties as $dirty_property) {
          // Separate property name from its value.
          if (!preg_match('#^([a-zA-Z][-a-zA-Z]*)\s*:\s*(.*)$#', $dirty_property, $property_matches)) {
            // Ignore properties that do not match the format "property-name: value".
            continue;
          }
          $property_name = &$property_matches[1];
          $property_value = &$property_matches[2];
          if (!isset($allowed_properties[$property_name])) {
            // Ignore property if not whitelisted in filter settings.
            continue;
          }

          // Filter property value for bad protocols (note that property value has already been decoded).
          $property_value = wysiwyg_filter_xss_bad_protocol($property_value);
          if (!preg_match($allowed_properties[$property_name], $property_value)) {
            // Ignore property if value does not match syntax rules.
            continue;
          }

          // If property value comes with url(...), then we want to check if it's allowed or not.
          if (strpos($property_value, 'url(') !== FALSE) {
            if (count($allowed_style_urls) <= 0) {
              // Ignore property if no rules have been specified.
              continue;
            }

            // This is like $regexp_uri in wysiwyg_filter_get_style_property_groups(), but it now contains 2 capturing
            // groups [1] for the URL itself (including delimiters) and [2] the first delimiter (if any).
            if (!preg_match('`url\(\s*(([\'"]?)(?:[^)]|(?<=\\\\)\\))+[\'"]?)\s*\)`', $property_value, $url) || empty($url[1])) {
              // Ignore property if found to be malformed here.
              continue;
            }
            if (!empty($url[2])) {
              if (substr($url[1], -1) != $url[2]) {
                // Ignore property if start and end delimiters don't match.
                continue;
              }
              // Remove delimiters.
              $url[1] = substr($url[1], 1, -1);
            }
            // Remove backslashes that could have been used to escape parentheses,
            // commas, whitespace characters, single quotes or double quotes.
            // http://www.w3.org/TR/CSS2/syndata.html#uri
            $url = preg_replace('`\\\\([(),\'"\s])`', '\1', $url[1]);

            // Check URL against advanced filter rules.
            $match_found = FALSE;
            foreach ($allowed_style_urls as $regexp) {
              if (preg_match($regexp, $url)) {
                $match_found = TRUE;
                break;
              }
            }
            if (!$match_found) {
              // Ignore property if URL does not match with any rule.
              continue;
            }
          }

          // Sanitized property name and value (check_plain'd here).
          $sanitized_properties[] = $property_name .':'. check_plain($property_value);
        }

        if (empty($sanitized_properties)) {
          // Ignore the whole style attribute if no property remains.
          continue;
        }

        $attrinfo['value'] = implode('; ', $sanitized_properties);
      }
      else if ($attrname == 'class') {
        // Validate class names based on advanced rules specified in filter settings panel.
        $dirty_names = array_filter(array_map('trim', explode(' ', decode_entities($attrinfo['value']))));
        $valid_names = array();
        foreach ($dirty_names as $dirty_name) {
          foreach ($allowed_class_names as $regexp) {
            if (preg_match($regexp, $dirty_name)) {
              $valid_names[] = $dirty_name;
            }
          }
        }
        if (empty($valid_names)) {
          // Ignore attribute if no valid class name remains.
          continue;
        }
        $attrinfo['value'] = check_plain(implode(' ', $valid_names));
      }
      else if ($attrname == 'id') {
        // Validate element IDs based on advanced rules specified in filter settings panel.
        if (count($allowed_element_ids) <= 0) {
          // Ignore attribute if no rules have been specified.
          continue;
        }
        // Decode value so we can easilly check it.
        $attrinfo['value'] = decode_entities($attrinfo['value']);
        // Pattern starts valid, but it should match all specified rules.
        $match_found = FALSE;
        foreach ($allowed_element_ids as $regexp) {
          if (preg_match($regexp, $attrinfo['value'])) {
            $match_found = TRUE;
            break;
          }
        }
        if (!$match_found) {
          // Ignore if it contains invalid value.
          continue;
        }
        // Element ID is valid, check_plain result.
        $attrinfo['value'] = check_plain($attrinfo['value']);
      }
      else {
        // All attribute values are checked for bad protocols. This is the same
        // exact method used by Drupal's filter_xss().
        $attrinfo['value'] = filter_xss_bad_protocol($attrinfo['value']);

        // If this is <a href> element, then check domain name for rel="nofollow" policies in effect.
        if ($element == 'a' && $attrname == 'href' && $nofollow_policy != 'disabled' && !$add_nofollow) {
          $domain_found = FALSE;
          foreach ($nofollow_domains as $domain) {
            if (preg_match('#://.*'. $domain .'([^a-z0-9]|$)#i', $attrinfo['value'])) {
              $domain_found = TRUE;
              break;
            }
          }
          if (($nofollow_policy == 'blacklist' && $domain_found) || ($nofollow_policy == 'whitelist' && !$domain_found)) {
            $add_nofollow = TRUE;
          }
        }
      }

      // Build parsed attribute value.
      $parsed_attribute .= '='. $attrinfo['delimiter'] . $attrinfo['value'] . $attrinfo['delimiter'];
    }

    $parsed_attributes[$attrname] = $parsed_attribute;
  }

  // Do we have a link where rel="nofollow" should be added?
  if ($add_nofollow) {
    if (empty($parsed_attributes['rel'])) {
      $parsed_attributes['rel'] = 'rel="nofollow"';
    }
    else if (strpos($parsed_attributes['rel'], 'nofollow') === FALSE) {
      // Since we know the attribute is well formed, we can use substr(), which is faster than preg_replace().
      $parsed_attributes['rel'] = substr($parsed_attributes['rel'], 0, -1) .' nofollow'. substr($parsed_attributes['rel'], -1);
    }
  }

  return $parsed_attributes;
}

/**
 * Processes an style property value and ensures it does not contain an URL
 * with a disallowed protocol (e.g. javascript:)
 *
 * This function is based on Drupal's filter_xss_bad_protocol(). Differences are:
 * 1) It does not decode input string. Done in caller before calling us.
 * 2) It does not apply check_plain() to result. Done in caller after calling us.
 * 3) It allows a lot less protocols (http and https only).
 *
 * @param $string
 *   The string with the style property value.
 * @return
 *   Cleaned up version of $string.
 */
function wysiwyg_filter_xss_bad_protocol($string) {
  $allowed_protocols = array('http' => 1, 'https' => 1);

  // Iteratively remove any invalid protocol found.

  do {
    $before = $string;
    $colonpos = strpos($string, ':');
    if ($colonpos > 0) {
      // We found a colon, possibly a protocol. Verify.
      $protocol = substr($string, 0, $colonpos);
      // If a colon is preceded by a slash, question mark or hash, it cannot
      // possibly be part of the URL scheme. This must be a relative URL,
      // which inherits the (safe) protocol of the base document.
      if (preg_match('![/?#]!', $protocol)) {
        break;
      }
      // Per RFC2616, section 3.2.3 (URI Comparison) scheme comparison must be case-insensitive
      // Check if this is a disallowed protocol.
      if (!isset($allowed_protocols[strtolower($protocol)])) {
        $string = substr($string, $colonpos + 1);
      }
    }
  } while ($before != $string);
  return $string;
}
